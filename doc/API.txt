==================================================================================
The Tokyo Project is hosted on Sourceforge:
http://sourceforge.net/projects/tokyo/

Copyright (c) 2005-2006 Eric Bréchemier
http://eric.brechemier.name

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
==================================================================================

=========================================
Title: Tokyo Project - Data handling API 
Last modified: 2006-11-17
By: Eric Bréchemier
Encoding: UTF-8
=========================================

                        *******************************   
                        **       Tokyo Project       **
                        **     Data Handling API     **
                        *******************************


This documents defines the "TokyoNautilus" data handling API designed as part of Tokyo Project.
This API is at the center of data access in the differents tools demonstrated in this project.

The TokyoNautilus API enables both XML and non-XML data browsing through a concise API. Nautilus is a 
reference to Captain Nemo's submarine in "Twenty Thousand Leagues Under the Sea" by Jules Verne.
Captain Nemo's motto, "Mobilis in Mobili", fits well with this flexible data navigation API. 

TokyoNautilus API is composed of a single interface, ITokyoNaut, with the five following methods:
  
  Two Methods Framing the Transaction 
  -----------------------------------
  * meet(ITokyoNaut stranger, Object[] context, int[] type, int language) : void
      Every data processing starts with such a meeting between two TokyoNaut instances.
      The stranger instance is to propose a language stored in context[language], with
      type[language] characterizing the language Object using a shared convention. 
      The hearer TokyoNaut may either say something using the language, or keep silent 
      and quit, using the same context, type and language as arguments.
      
      Note: TokyoNaut API makes extensive use of the three parameters
        Object[] context + int[] type + int someObjectPosition.
        The combination of context and type can be seen as a stack of named arguments,
        while the last integer parameter points to the top of the stack. 
        The rule is rather to keep the same arrays for the duration of the conversation,
        even if bigger arrays may be introduced as required if shared conventions associated 
        with the current language allow it. Besides, the two arrays should have the same size.
      
  * quit(ITokyoNaut friend, Object[] context, int[] type, int language) : void
      At the end of all discussions, TokyoNauts part company; this is the occasion
      to free contextual ressources related to the task. Any TokyoNaut may end the discussion,
      not necessarily the one having started it by calling the meet method.
      context[language] and type[language] will usually be identical to the values
      provided in the initial meet method.
  
  Three Methods For Ostensive Communication
  ------------------------------------------
  * say(ITokyoNaut speaker, Object[] context, int[] type, int sentence) : void
      TokyoNauts instances communicate by calling alternatively this "say" method. 
      The speaker TokyoNaut says context[sentence], characterized by type[sentence], 
      assuming it is relevant in the context. 
      Each TokyoNaut is free to update the context stack to keep only the most relevant items. 
      For hierarchical data processing, the context may for example contain the stack of
      ancestors on the path from the root to the current node.
  
  * play(ITokyoNaut player, Object[] context, int[] type, int play) : void
      When tired of speaking, TokyoNauts can enjoy a little distraction by playing
      a quick game, a piece of music or even theater, proposed as context[play]. 
      Serious TokyoNauts can freely skip the implementation of this method.
    
  * show(ITokyoNaut shower, Object towel) : void
      Gestures provide alternative communication, especially useful for logs, 
      assertions and errors. No need to panic, says Japan coach.
  
The design of TokyoNautilus implementations can be successfully achieved by starting 
from the NullNautilus provided below, adding required functionalities as needed:

public class NullNautilus implements ITokyoNaut
{
  public void meet(ITokyoNaut stranger, Object[] context, int[] type, int language) { return; }
  public void quit(ITokyoNaut friend, Object[] context, int[] type, int language)   { return; }
  
  public void say(ITokyoNaut speaker, Object[] context, int[] type, int sentence)   { return; }
  public void play(ITokyoNaut player, Object[] context, int[] type, int play)       { return; }
  public void show(ITokyoNaut shower, Object towel)                                 { return; }
}


The Joshua class below exemplifies a fictionnal (but mostly harmless) TokyoNaut:

public class Joshua implements ITokyoNaut
{
  public static final int TYPE_PROPOSE_GAME_CHESS = 100;
  public static final int TYPE_REPLY_PROPOSE_GAME = 110;
  public static final int TYPE_REAL_DOUBT = 900;
  
  public void meet(ITokyoNaut stranger, Object[] context, int[] type, int language)
  {
    stranger.quit(this,context,type,language);
    return;
  }
  
  public void quit(ITokyoNaut friend, Object[] context, int[] type, int language)
  {
    if ( isSafe(friend,context,type,language) ) {
      int play = language+1;
      context[play] = "How about a nice game of chess?";
      type[play] = TYPE_PROPOSE_GAME_CHESS;
      friend.play(this,context,type,play);
    }
    return;
  }
  
  public void say(ITokyoNaut speaker, Object[] context, int[] type, int sentence)
  {
    if ( isSafe(speaker,context,type,sentence) ) {
      int play = sentence+1;
      context[play] = "Is it a game, or is it real?";
      type[play] = TYPE_REAL_DOUBT;
      speaker.play(this,context,type,play);
    }
    return;
  }
  
  public void play(ITokyoNaut player, Object[] context, int[] type, int play)
  {
    if ( isSafe(player,context,type,play) ) {
      int reply = play+1;
      context[reply] = "Shall we play a game?";
      type[reply] = TYPE_REPLY_PROPOSE_GAME;
      player.say(this,context,type,reply);
    }
    return;
  }
    
  public void show(ITokyoNaut shower, Object towel)
  {
    System.err.println("Don't Panic! "+shower+" knows where his "+towel+" is.");
    return;
  }
  
  private boolean isSafe(ITokyoNaut friend, Object[] context, int[] type, int position)
  {
    if
      (
        (friend != null)
        &&
        (context != null)
        &&
        (context.length >0)
        &&
        (0 <= position && position < context.length-1)
        &&
        (type != null)
        &&
        (type.length == context.length)
      )
    {
      return true;
    }
    else
    {
      friend.show(this,"Error: Invalid parameters or context buffer too small");
      return false;
    }
  }
  
}

In order to conclude this introduction to TokyoNaut API, we will present below a 
step by step description of the prototype 1 conception. This prototype consists in 
handling the sorting of countries in a CSV file using XSLT, by mapping CSV data to SAX 
events to process it as if it was vanilla XML:

1°) First, Know Your Enemy. We start with an exploration of the custom input format possibilities
and complexities; in this case, we will read and print the input CSV file to System.out.

The CSV file looks like this, with each line terminated by '\r\n':

  France,Paris,Europe
  Canada,Toronto,America
  Japan,Tokyo,Asia

And here is some Java code loading the file and printing all lines and fields to System.out:

  public static void parseAll(String fileName)
  {
    try
    {
      BufferedReader br = new BufferedReader( new FileReader(fileName) );
      int ch;
      int lineCount = 1;
      int fieldCount = 0;
      boolean isStartLine = true;
      boolean isStartField = true;
      boolean isEndOfFile = false;
      do
      {
        if (isStartLine)
        {
          System.out.print("\nLine "+lineCount+":");
          fieldCount=0;
          isStartField = true;
          lineCount++;
          isStartLine = false;
        }
        
        if (isStartField)
        {
          fieldCount++;
          System.out.print("\n\tField "+fieldCount+": ");
          isStartField = false;
        }
        
        ch = br.read();
        
        switch(ch)
        {
          case '\r':
            break;
            
          case '\n':
            isStartLine = true;
            break;
          
          case ',':
            isStartField = true;
            break;
          
          case -1:
            isEndOfFile = true;
            break;
          
          default:
            System.out.print((char)ch);
        
        }
        
      } while (!isEndOfFile);
    }
    catch(Exception e)
    {
      System.err.println("ERROR: "+ e);
      e.printStackTrace();
    }
    finally
    {
      System.out.flush();
    }
  }

2°) Estimate Your Strengths. Let's now play with the equivalent XML file, to help us design the 
processing taking place after the conversion to SAX events; this is one possibility of an 
XML structure equivalent to our CSV data sample:

  <csv xmlns="http://tokyo.sf.net/prototype1/csv">
    <line>
      <field>France</field>
      <field>Paris</field>
      <field>Europe</field>
    </line>
    <line>
      <field>Canada</field>
      <field>Toronto</field>
      <field>America</field>
    </line>
    <line>
      <field>Japan</field>
      <field>Tokyo</field>
      <field>Asia</field>
    </line>
  </csv>

Using this XML as input, we can now write one XSLT transformation to reorder the data by continent name, 
then country name:

  <?xml version="1.0" encoding="UTF-8"?>
  <xsl:transform
   xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
   version="1.0"
   
   xmlns:data="http://tokyo.sf.net/prototype1/csv"
  >
    <!--
    Implementation part of XSL Transformation:
    Reorder {"countries","http://tokyo.sf.net/prototype1/countries"}
    -->
    
    <xsl:template match="data:csv">
      <xsl:copy>
        <xsl:copy-of select="@*" />
        <xsl:apply-templates select="data:line">
          <xsl:sort select="data:field[3]" />
          <xsl:sort select="data:field[1]" />
        </xsl:apply-templates>
      </xsl:copy>
    </xsl:template>
    
    <xsl:template match="data:line">
      <xsl:copy-of select="." />
    </xsl:template>
  
  </xsl:transform>

The resulting file is:

  <csv xmlns="http://tokyo.sf.net/prototype1/csv">
    <line>
      <field>Canada</field>
      <field>Toronto</field>
      <field>America</field>
    </line>
    <line>
      <field>Japan</field>
      <field>Tokyo</field>
      <field>Asia</field>
    </line>
    <line>
      <field>France</field>
      <field>Paris</field>
      <field>Europe</field>
    </line>
  </csv>


3°) Know Who Your Allies Are. When executing the XSLT transformation, the XML file is parsed and 
SAX events corresponding to the different nodes found during the parsing are provided to the XSLT 
processor. Before replacing events coming from the XML source by events coming from a non-XML source, 
we will first insert a filter between the event source, the XML Parser, and the event listener, the 
XSLT Processor: 

public class Step3_SaxFilter
  implements XMLReader, ErrorHandler,ContentHandler,DTDHandler,LexicalHandler
{
  (...)
  
  public void setContentHandler(ContentHandler handler)
  {
    log("setContentHandler("+handler+")",2);
    _contentHandler = handler;
    _parser.setContentHandler(this);
  }
  
  public ContentHandler getContentHandler()
  {
    log("getContentHandler() : "+_contentHandler,3);
    return _contentHandler;
  }
  
  public void parse(InputSource input)
      throws IOException, SAXException
  {
    log("parse("+input+")",2);
    _parser.parse(input);
  }
  
  (...)
  
  public void startDocument()
	  throws SAXException
  {
    log("startDocument()",4);
    _contentHandler.startDocument();
  }
  
  (...)
}


4°) Know Yourself. Finally, we can now adapt the CSV processing code for SAX Events generation, 
and replace the XML Parser events. This can be easily done in two steps using the Tokyo Nautilus
Architecture: 
- starting from previous SAX Filter, we can make it implement the ITokyoNaut interface:

public class Step4_CsvToSaxNaut
  implements XMLReader,ErrorHandler,ContentHandler,Locator,DTDHandler,LexicalHandler,
             ITokyoNaut
{

  (...)
  
  public void say(ITokyoNaut speaker, Object[] context, int[] type, int sentence)
  {
    try
    {
      log("say("+speaker+","+context+"=>"+context[sentence]+","+type+"=>"+type[sentence]+","+sentence+")",3);
      
      int[] lineCol = (int[])context[TYPE_SAX_DOCUMENT_LINE_COLUMN];
      _lineNumber = lineCol[0];
      _columnNumber = lineCol[1]; 
      
      switch(type[sentence])
      {
        case TYPE_SAX_CONTENT_START_DOCUMENT:
          {
          _contentHandler.startDocument();
          }
          break;
        
        case TYPE_SAX_CONTENT_START_PREFIX_MAPPING:
          {
          // pop arguments from Context Stack
          String prefix = (String)context[sentence+1];
          String uri = (String)context[sentence+2];
          _contentHandler.startPrefixMapping(prefix,uri);
          }
          break;
        
        case TYPE_SAX_CONTENT_START_ELEMENT:
          {
          // pop arguments from Context Stack
          String uri = (String)context[sentence+1];
          String localName = (String)context[sentence+2];
          String qName = (String)context[sentence+3];
          Attributes atts = (Attributes)context[sentence+4];
          _contentHandler.startElement(uri,localName,qName,atts);
          }
          break;
        
        case TYPE_SAX_CONTENT_CHARACTERS:
          {
          // pop arguments from Context Stack
          char[] characters = (char[])context[sentence+1];
          int[] startLength = (int[])context[sentence+2];
          int start = startLength[0];
          int length = startLength[1];
          _contentHandler.characters(characters,start,length);
          }
          break;
        
        case TYPE_SAX_CONTENT_END_ELEMENT:
          {
          // pop arguments from Context Stack
          String uri = (String)context[sentence+1];
          String localName = (String)context[sentence+2];
          String qName = (String)context[sentence+3];
          _contentHandler.endElement(uri,localName,qName);
          }
          break;
          
        case TYPE_SAX_CONTENT_END_PREFIX_MAPPING:
          {
          // pop arguments from Context Stack
          String prefix = (String)context[sentence+1];
          _contentHandler.endPrefixMapping(prefix);
          }
          break;
        
        case TYPE_SAX_CONTENT_END_DOCUMENT:
          {
          _contentHandler.endDocument();
          speaker.quit(this,context,type,TYPE_SAX_LANGUAGE);
          }
          break;
        
        case TYPE_SAX_CONTENT_IGNORABLE_WHITE_SPACE:
          {
          // pop arguments from Context Stack
          char[] characters = (char[])context[sentence+1];
          int[] startLength = (int[])context[sentence+2];
          int start = startLength[0];
          int length = startLength[1];
          _contentHandler.ignorableWhitespace(characters,start,length);
          }
          break;
        
        case TYPE_SAX_CONTENT_PROCESSING_INSTRUCTION:
          {
          // pop arguments from Context Stack
          String target = (String)context[sentence+1];
          String data = (String)context[sentence+2];
          _contentHandler.processingInstruction(target,data);
          }
          break;
        
        case TYPE_SAX_CONTENT_SKIPPED_ENTITY:
          {
          // pop arguments from Context Stack
          String entity_name = (String)context[sentence+1];
          _contentHandler.skippedEntity(entity_name);
          }
          break;
        
        default:
          speaker.show(this,"Unknown type: "+type[sentence]);
      }
      
    }
    catch(SAXException e)
    {
      if (speaker!=null)
        speaker.show(this,"SAX Error: "+e);
      else
        log("Invalid speaker="+speaker,5);
    }
    catch(Exception e)
    {
      if (speaker!=null)
        speaker.show(this,"Unexpected exception: "+e);
      else
        log("Invalid speaker="+speaker,5);
    }
  }

  (...)
}

- after adaptation to the ITokyoNaut interface, the custom CSV parser can now discuss with the SAX Filter
and communicate the SAX-like events generated from the CSV data:

  (...)
  
  protected void startElement(String elementName, ITokyoNaut destNaut, Object[] context, int[] type)
  {
    initContext(context);
    type[TYPE_SAX_EVENT] = TYPE_SAX_CONTENT_START_ELEMENT;
    argCount[0] = 4;
    type[TYPE_SAX_ARG1] = TYPE_SAX_ARG_NAMESPACE_URI;
    context[TYPE_SAX_ARG1] = NAMESPACE;
    type[TYPE_SAX_ARG2] = TYPE_SAX_ARG_LOCAL_NAME;
    context[TYPE_SAX_ARG2] = elementName;
    type[TYPE_SAX_ARG3] = TYPE_SAX_ARG_QNAME;
    context[TYPE_SAX_ARG3] = elementName;
    type[TYPE_SAX_ARG4] = TYPE_SAX_ARG_ATTRIBUTES;
    context[TYPE_SAX_ARG4] = NO_ATTRIBUTES;
    destNaut.say(this,context,type,TYPE_SAX_EVENT);
  }
  
  (...)
  
  public void meet(ITokyoNaut stranger, Object[] context, int[] type, int language)
  {
    try
    {
      if ( !SAX_EVENTS_LANG.equals(context[language]) )
      {
        stranger.quit(this,context,type,language);
        return;
      }
      
      InputSource input = (InputSource)context[TYPE_SAX_DOCUMENT_INPUT_SOURCE];
      String systemId = input.getSystemId();
      final String FILE_PREFIX = "file:";
      // Remove starting "file:"
      String path = systemId.substring(FILE_PREFIX.length());
      
      parseAll( path, stranger,context,type,language);
      
    }
    catch(Exception e)
    {
      if (stranger!=null)
        stranger.show(this,"Unexpected exception: "+e);
      else
        System.err.println("Invalid stranger: "+stranger);
    }
  }

At this step, CSV is processed transparently as if it was XML, and an XML file is generated at the 
end of the transformation.

6°) Complete the picture. With CSV parsing "à la XML" complete, the first prototype can then be 
finalized by serializing the result as CSV using two different methods:
- a simple XSLT transformation producing CSV text from "CSV XML"

  <?xml version="1.0" encoding="UTF-8"?>
  <xsl:transform
   xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
   version="1.0"
   
   xmlns:data="http://tokyo.sf.net/prototype1/csv"
  >
    <xsl:output method="text" />
    
    <xsl:template match="data:line">
      <xsl:value-of select="data:field[1]"/>
      <xsl:call-template name="Separator"/>
      <xsl:value-of select="data:field[2]"/>
      <xsl:call-template name="Separator"/>
      <xsl:value-of select="data:field[3]"/>
      <xsl:call-template name="newLine"/>
    </xsl:template>
    
    <xsl:template match="text()" />
    
    <xsl:template name="Separator">
      <xsl:text>,</xsl:text>
    </xsl:template>
    
    <xsl:template name="newLine">
      <xsl:text>&#xD;&#xA;</xsl:text>
    </xsl:template>
    
  </xsl:transform>

  
- a custom CSV Serializer (TokyoNautilus-based), replacing the standard XML serializer:
  
  public void say(ITokyoNaut speaker, Object[] context, int[] type, int sentence)
  {
    try
    {
      switch(type[sentence])
      {
        case Step5_Sax.CONTENT_START_ELEMENT:
          {
            // pop arguments from Context Stack
            String uri = (String)context[sentence+1];
            String localName = (String)context[sentence+2];
            // (unused) String qName = (String)context[sentence+3];
            // (unused) Attributes atts = (Attributes)context[sentence+4];
            if ( NAMESPACE.equals(uri) ) 
            {
              if ( LINE_ELEMENT.equals(localName) )
              {
                _isStartOfLine = true;
              }
              else if ( FIELD_ELEMENT.equals(localName) )
              {
                if (_isStartOfLine)
                  _isStartOfLine = false;
                else
                  _writer.write(','); 
              }
            }
          }
          break;
        
        case Step5_Sax.CONTENT_CHARACTERS:
          {
            // pop arguments from Context Stack
            char[] characters = (char[])context[sentence+1];
            int[] startLength = (int[])context[sentence+2];
            int start = startLength[0];
            int length = startLength[1];
            _writer.write(characters,start,length);
          }
          break;
        
        case Step5_Sax.CONTENT_END_ELEMENT:
          {
            // pop arguments from Context Stack
            String uri = (String)context[sentence+1];
            String localName = (String)context[sentence+2];
            String qName = (String)context[sentence+3];
            if ( NAMESPACE.equals(uri) )
            {
              if ( LINE_ELEMENT.equals(localName) )
              {
                _writer.write('\r');
                _writer.write('\n');
              } 
            }
          }
          break;
        
        case Step5_Sax.CONTENT_END_DOCUMENT:
          _writer.flush();
          freeWriter();
          break;
        
        case Step5_Sax.CONTENT_START_DOCUMENT:
        case Step5_Sax.CONTENT_START_PREFIX_MAPPING:
        case Step5_Sax.CONTENT_END_PREFIX_MAPPING:
        case Step5_Sax.CONTENT_IGNORABLE_WHITE_SPACE:
        case Step5_Sax.CONTENT_PROCESSING_INSTRUCTION:
        case Step5_Sax.CONTENT_SKIPPED_ENTITY:
          break;
        
        default:
          speaker.show(this,"Unknown type: "+type[sentence]);
      }
      
    }
    catch(IOException e)
    {
      freeWriter();
      if (speaker!=null)
        speaker.show(this,"Unexpected exception: "+e);
      else
      {
        System.err.println("Error: "+e);
        e.printStackTrace();
      }
    }
    catch(Exception e)
    {
      if (speaker!=null)
        speaker.show(this,"Unexpected exception: "+e);
      else
      {
        System.err.println("Error: "+e);
        e.printStackTrace();
      }
    }
  }

We can now check that the CSV produced by the two equivalent processing chains is identical:
- on one hand, CSV resulting from XSLT transformations applied to the XML sample
- on the other hand, CSV processed by XSLT combined with custom CSV parser and custom CSV serializer.

=============== END OF DOCUMENT: Tokyo Project - Data handling API ===============