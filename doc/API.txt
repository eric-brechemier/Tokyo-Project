==================================================================================
The Tokyo Project is hosted on Sourceforge:
http://sourceforge.net/projects/tokyo/

Copyright (c) 2005-2006 Eric Bréchemier
http://eric.brechemier.name

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
==================================================================================

=========================================
Title: Tokyo Project - Data handling API 
Last modified: 2006-11-06
By: Eric Bréchemier
Encoding: UTF-8
=========================================

                        *******************************   
                        **       Tokyo Project       **
                        **     Data Handling API     **
                        *******************************


This documents defines the "TokyoNautilus" data handling API designed as part of Tokyo Project.
This API is at the center of data access in the differents tools demonstrated in this project.

The TokyoNautilus API enables both XML and non-XML data browsing through a concise API. Nautilus is a 
reference to Captain Nemo's submarine in "Twenty Thousand Leagues Under the Sea" by Jules Verne.
Captain Nemo's motto, "Mobilis in Mobili", fits well with this flexible data navigation API. 

TokyoNautilus API is composed of a single interface, ITokyoNaut, with the five following methods:
  
  Two Methods Framing the Transaction 
  -----------------------------------
  * meet(ITokyoNaut stranger, Object[] context, int[] type, int language) : void
      Every data processing starts with such a meeting between two TokyoNaut instances.
      The stranger instance is to propose a language stored in context[language], with
      type[language] characterizing the language Object using a shared convention. 
      The hearer TokyoNaut may either say something using the language, or keep silent 
      and quit, using the same context, type and language as arguments.
      
      Note: TokyoNaut API makes extensive use of the three parameters
        Object[] context + int[] type + int someObjectPosition.
        The combination of context and type can be seen as a stack of named arguments,
        while the last integer parameter points to the top of the stack. 
        The rule is rather to keep the same arrays for the duration of the conversation,
        even if bigger arrays may be introduced as required if shared conventions associated 
        with the current language allow it. Besides, the two arrays should have the same size.
      
  * quit(ITokyoNaut friend, Object[] context, int[] type, int language) : void
      At the end of all discussions, TokyoNauts part company; this is the occasion
      to free contextual ressources related to the task. Any TokyoNaut may end the discussion,
      not necessarily the one having started it by calling the meet method.
      context[language] and type[language] will usually be identical to the values
      provided in the initial meet method.
  
  Three Methods For Ostensive Communication
  ------------------------------------------
  * say(ITokyoNaut speaker, Object[] context, int[] type, int sentence) : void
      TokyoNauts instances communicate by calling alternatively this "say" method. 
      The speaker TokyoNaut says context[sentence], characterized by type[sentence], 
      assuming it is relevant in the context. 
      Each TokyoNaut is free to update the context stack to keep only the most relevant items. 
      For hierarchical data processing, the context may for example contain the stack of
      ancestors on the path from the root to the current node.
  
  * play(ITokyoNaut player, Object[] context, int[] type, int play) : void
      When tired of speaking, TokyoNauts can enjoy a little distraction by playing
      a quick game, a piece of music or even theater, proposed as context[play]. 
      Serious TokyoNauts can freely skip the implementation of this method.
    
  * show(ITokyoNaut shower, Object towel) : void
      Gestures provide alternative communication, especially useful for logs, 
      assertions and errors. No need to panic, says Japan coach.
  
The design of TokyoNautilus implementations can be successfully achieved by starting 
from the NullNautilus provided below, adding required functionalities as needed:

public class NullNautilus implements ITokyoNaut
{
  public void meet(ITokyoNaut stranger, Object[] context, int[] type, int language) { return; }
  public void quit(ITokyoNaut friend, Object[] context, int[] type, int language)   { return; }
  
  public void say(ITokyoNaut speaker, Object[] context, int[] type, int sentence)   { return; }
  public void play(ITokyoNaut player, Object[] context, int[] type, int play)       { return; }
  public void show(ITokyoNaut shower, Object towel)                                 { return; }
}


The Joshua class below exemplifies a fictionnal (but mostly harmless) TokyoNaut:

public class Joshua implements ITokyoNaut
{
  public static final int TYPE_PROPOSE_GAME_CHESS = 100;
  public static final int TYPE_REPLY_PROPOSE_GAME = 110;
  public static final int TYPE_REAL_DOUBT = 900;
  
  public void meet(ITokyoNaut stranger, Object[] context, int[] type, int language)
  {
    stranger.quit(this,context,type,language);
    return;
  }
  
  public void quit(ITokyoNaut friend, Object[] context, int[] type, int language)
  {
    if ( isSafe(friend,context,type,language) ) {
      int play = language+1;
      context[play] = "How about a nice game of chess?";
      type[play] = TYPE_PROPOSE_GAME_CHESS;
      friend.play(this,context,type,play);
    }
    return;
  }
  
  public void say(ITokyoNaut speaker, Object[] context, int[] type, int sentence)
  {
    if ( isSafe(speaker,context,type,sentence) ) {
      int play = sentence+1;
      context[play] = "Is it a game, or is it real?";
      type[play] = TYPE_REAL_DOUBT;
      speaker.play(this,context,type,play);
    }
    return;
  }
  
  public void play(ITokyoNaut player, Object[] context, int[] type, int play)
  {
    if ( isSafe(player,context,type,play) ) {
      int reply = play+1;
      context[reply] = "Shall we play a game?";
      type[reply] = TYPE_REPLY_PROPOSE_GAME;
      player.say(this,context,type,reply);
    }
    return;
  }
    
  public void show(ITokyoNaut shower, Object towel)
  {
    System.err.println("Don't Panic! "+shower+" knows where his "+towel+" is.");
    return;
  }
  
  private boolean isSafe(ITokyoNaut friend, Object[] context, int[] type, int position)
  {
    if
      (
        (friend != null)
        &&
        (context != null)
        &&
        (context.length >0)
        &&
        (0 <= position && position < context.length-1)
        &&
        (type != null)
        &&
        (type.length == context.length)
      )
    {
      return true;
    }
    else
    {
      friend.show(this,"Error: Invalid parameters or context buffer too small");
      return false;
    }
  }
  
}

In order to conclude this introduction to TokyoNaut API, we will present below a 
step by step description of the prototype 1 conception. This prototype consists in 
handling the sorting of countries in a CSV file using XSLT, by mapping CSV data to SAX 
events to process it as if it was vanilla XML:

1°) First, Know Your Enemy. We start with an exploration of the custom input format possibilities
and complexities; in this case, we will read and print the input CSV file to System.out.

The CSV file looks like this, with each line terminated by '\r\n':

France,Paris,Europe
Canada,Toronto,America
Japan,Tokyo,Asia

And here is some Java code loading the file and printing all lines and fields to System.out:

public static void parseAll(String fileName)
{
  try
  {
    BufferedReader br = new BufferedReader( new FileReader(fileName) );
    int ch;
    int lineCount = 1;
    int fieldCount = 0;
    boolean isStartLine = true;
    boolean isStartField = true;
    boolean isEndOfFile = false;
    do
    {
      if (isStartLine)
      {
        System.out.print("\nLine "+lineCount+":");
        fieldCount=0;
        isStartField = true;
        lineCount++;
        isStartLine = false;
      }
      
      if (isStartField)
      {
        fieldCount++;
        System.out.print("\n\tField "+fieldCount+": ");
        isStartField = false;
      }
      
      ch = br.read();
      
      switch(ch)
      {
        case '\r':
          break;
          
        case '\n':
          isStartLine = true;
          break;
        
        case ',':
          isStartField = true;
          break;
        
        case -1:
          isEndOfFile = true;
          break;
        
        default:
          System.out.print((char)ch);
      
      }
      
    } while (!isEndOfFile);
  }
  catch(Exception e)
  {
    System.err.println("ERROR: + e");
    e.printStackTrace();
  }
  finally
  {
    System.out.flush();
  }
}

2°) Estimate Your Strengths. Let's now play with the equivalent XML file, to help us design the 
processing taking place after the conversion to SAX events; this is one possibility of an 
XML structure equivalent to our CSV data sample:

<csv xmlns="http://tokyo.sf.net/prototype1/csv">
  <line>
    <field>France</field>
    <field>Paris</field>
    <field>Europe</field>
  </line>
  <line>
    <field>Canada</field>
    <field>Toronto</field>
    <field>America</field>
  </line>
  <line>
    <field>Japan</field>
    <field>Tokyo</field>
    <field>Asia</field>
  </line>
</csv>

Using this XML as input, we can now write one XSLT transformation to reorder the data by continent name, 
then country name:
<?xml version="1.0" encoding="UTF-8"?>
<xsl:transform
 xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
 version="1.0"
 
 xmlns:data="http://tokyo.sf.net/prototype1/csv"
>
  <!--
  Implementation part of XSL Transformation:
  Reorder {"countries","http://tokyo.sf.net/prototype1/countries"}
  -->
  
  <xsl:template match="data:csv">
    <xsl:copy>
      <xsl:apply-templates select="data:line">
        <xsl:sort select="data:field[3]" />
        <xsl:sort select="data:field[1]" />
      </xsl:apply-templates>
    </xsl:copy>
  </xsl:template>
  
  <xsl:template match="data:line">
    <xsl:copy-of select="." />
  </xsl:template>

</xsl:transform>

The resulting file is:
<csv xmlns="http://tokyo.sf.net/prototype1/csv">
  <line>
    <field>Canada</field>
    <field>Toronto</field>
    <field>America</field>
  </line>
  <line>
    <field>Japan</field>
    <field>Tokyo</field>
    <field>Asia</field>
  </line>
  <line>
    <field>France</field>
    <field>Paris</field>
    <field>Europe</field>
  </line>
</csv>


3°) Know Who Your Allies Are. When executing the XSLT transformation, the XML file is parsed and 
SAX events corresponding to the different nodes found during the parsing are provided to the XSLT 
processor. Before replacing events coming from the XML source by events coming from a non-XML source, 
we will first filter these events to know them better and record them in order to be able to replay 
the flow of events without the source, which results in a simulated parsing.


4°) Know Yourself. We can now replay the recorded events and check that the results are unchanged.


5°) Friends Will Be Friends. Finally, we can now adapt the CSV processing code for SAX Events generation, 
and replace the previous simulation. At this step, CSV is processed transparently as if it was XML, 
and an XML file is generated at the end of the transformation. 

6°) Complete the picture. The first prototype can then be finalized by serializing the result as CSV, 
demonstrating two different methods:
- an XSLT transformation producing CSV text from "CSV XML"
- a custom Serializer to our CSV format, replacing the standard XML serializer

We can now check that the CSV produced by the two equivalent processing chains is identical:
- on one hand, CSV resulting from XSLT transformations applied to the XML sample
- on the other hand, CSV processed by XSLT combined with custom CSV parser and custom CSV serializer.

=============== END OF DOCUMENT: Tokyo Project - Data handling API ===============