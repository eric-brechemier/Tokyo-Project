==================================================================================
The Tokyo Project is hosted on Sourceforge:
http://sourceforge.net/projects/tokyo/

Copyright (c) 2005-2007 Eric Bréchemier
http://eric.brechemier.name

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
==================================================================================

=========================================
Title: Tokyo Project - Data Handling API 
Last modified: 2007-05-01
By: Eric Bréchemier
Encoding: UTF-8
=========================================

                        *******************************   
                        **       Tokyo Project       **
                        **     Data Handling API     **
                        *******************************


This documents defines the Tokyo API designed as part of the Tokyo Project. The Tokyo API is 
at the core of custom data handling in the differents applications demonstrated in this project.

Tokyo API enables both XML and non-XML data transformations through a concise API: 
it is made of one interface, ITokyoNaut, with a single method, "morph":

public interface ITokyoNaut
{
  public ITokyoNaut morph(Object[] state, ITokyoNaut[] rules, Object[] data, int[] index);
}

The name "TokyoNaut" is composed of "Tokyo", a mind-changing city where this project started, 
while "Naut" is a shorthand reference to Nautilus, Captain Nemo's submarine in Jules Verne's
"Twenty Thousand Leagues Under the Sea". 
More inspiration comes from Captain Nemo's motto: "Mobilis in Mobili".

Instances of classes that implement the ITokyoNaut interface are called TokyoNaut instances, or 
simply TokyoNauts. Their mission is to rewrite incrementally some input data, one step at a time.
Each call of the "morph" method runs one single rewrite step, which could correspond to one line 
of text, one binary structure or an XML fragment depending on the format at hand and the choice 
of implementation.

The order of "morph" parameters can be easily remembered with the sentence: "State rules data index."
which has no hidden purpose excepted mnemotechnics.

TokyoNaut instances can be stateless; each one will be allocated one box in the "state" array
allowing to preserve some required properties or objects too costly to be created at each new run.

A set of simple TokyoNaut instances may be associated to realize a complex data transformation,
each one located in a separate row of the "rules" array.
Prototype One provides such an example, applied to CSV data about World Countries.

"state" and "data" have the same number of elements as "rules". The association of these three 
arrays can be seen as a table where the row of index "i" is made of (state[i],rules[i],data[i]).

"index" is a single element array (int[1]) providing current index as a read/write parameter.
The current index is the position of the current TokyoNaut, which will execute its atomic morph 
operation in the run of the morph call.

The returned TokyoNaut instance is the next to be called to continue the transformation process,
or null if the transformation is complete (in which case index[0] shall be set to rules.length).

Given that state, rules and data have been properly initialized, the following loop would run
a step by step transformation until completion:

ITokyoNaut current = rules[0];
int[] index = new int[1]; 
while (current != null)
{
  current = current.morph(state,rules,data,index);
}

In the above example, it is not possible to replace the "while loop" with a "for loop",
because the flow of morph operations will typically loop back and forth from data providers
to data consumers, involding several passes trough the same TokyoNauts until completion.

=============== END OF DOCUMENT: Tokyo Project - Data Handling API ===============